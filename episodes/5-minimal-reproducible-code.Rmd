---
title: "Minimal Reproducible Code"
teaching: 10
exercises: 2
---

::: questions
- Why can't I just post my whole script?
- Which parts of my code are directly relevant to my problem?
- Which parts of my code are necessary in order for the problem area to run correctly?
- I feel overwhelmed by this script--where do I even start?
:::

::: objectives
- Explain the value of a minimal code snippet.
- Simplify a script down to a minimal code example.
- Identify the problem area of the code.
- Identify supporting parts of the code that are essential to include.
- Identify pieces of code that can be removed without affecting the central functionality.
- Have a road map to follow to simplify your code. [metacognitive LO]
:::

## Why is it important to simplify code?

::::::::::::::::::::::::::::::::::::::::::: challenge
**Exercise:** Imagine you're opening up a project after a long time away from it. You know you were stuck on one of the scripts, so you open it up to try to figure out what's going on. (If you have easy access to one of your past projects, try this in real time!)

On the Etherpad, write a few notes about the thoughts and feelings you experience when you do this. How do you feel about diving into this script again?
::::::::::::::::::::::::::::::::::::::::::: 

Now imagine that your colleague sends you *their* analysis script. It's broken and they want help fixing it. You open the script in R and it runs. Awesome! But now you're staring at a long complicated script, and you're not really sure where to start on fixing the problem.
- Ugh, this is going to take a long time. You're not exactly excited to dive into it.

When someone is doing you the favor of helping you figure out what's wrong with your code, the happier you make them, the likelier they are to help you quickly and easily. Why lay more barriers in their way?

This is especially important with strangers on the internet who don't have a pre-existing relationship with you. They're only going to help if you make it really really easy for them to do so.

XXX exercise that puts them in the shoes of the person receiving the example and trying to run it, so they feel how annoying it is.
XXX do we really need to hit them over the head with this? Maybe they get it already?

## Where is the problem area

So we've seen that simplifying your code down [helps other people help you](https://www.youtube.com/results?search_query=help+me+help+you+jenny+bryan) and gets you answers more quickly. But how do we actually do that?

In this episode, we're going to walk through a road map for breaking your code down to its simplest form while making sure that 1) it still runs and 2) it reproduces the problem you care about solving. In the last episode, we saw that a minimal dataset isn't useful if it doesn't demonstrate the thing you're trying to focus on! The same thing applies to code.

For now, we'll go through this road map step by step. At the end, we'll review it. One thing we want you to take away from this lesson is that there is a step by step process to follow, and you can refer back to it if you feel lost in the future.

Here's the road map we're going to follow:
[XXX DIAGRAM OF THE ROAD MAP]

**Step 0: Create a separate script**
Let's create a new script to store the simplified code.

::::::::::::::::::::::::::::::::::::::::::: 
File > New File > R Script
::::::::::::::::::::::::::::::::::::::::::: 

We'll call it something recognizable, such as "reprex-script.R"

**Step 1: Identify the problem area.**

The first step is to zero in on what's broken.

Sometimes, it's easy to tell which part of your code is broken. Everything was working, and then you add a new line and get an error. Other times, it's more subtle. The plot you're making doesn't look right. Your code gives an answer, but not the right answer. Maybe things were working last time you ran the script, but you've since added 50 more lines of code and you're not sure what's broken.

[XXX EXAMPLE WHERE THE PLOT CREATED DOESN'T MATCH WHAT THEY WERE GOING FOR] (because that's easier to debug than an actual error message). XXX we need to focus more on actual errors in this lesson I think... can add that in later.

Which line of code created that plot?
- If you're not sure, try stepping through your code line by line.

Now that we've identified the trouble spot, let's copy and paste it over to our script, "reprex-script.R".

XXX potentially add something about running the first half of the script and cutting down by halves

**Step 2: Dependencies (functions and packages)**

R code consists primarily of *variables* and *functions*. 

::::::::::::::::::::::::::::::::::::::::::: challenge
**Exercise:** Where do functions come from?

When coding in R, we use a lot of different functions. Where do those functions come from? How can we make sure that our helpers have access to those sources? Take a moment to brainstorm.
::::::::::::::::::::::::::::::::::::::::::: 
::: solution
Functions in R typically come from packages. Some packages, such as {base} and {stats}, are loaded in R by default, so you might not have realized that they are packages too.

You can see a complete list of functions in {base} and {stats} by running `library(help = "base")` or `library(help = "stats")`.

Some functions might be user-defined. In that case, you'll need to make sure to include the function definition in your reprex.

[RELEVANT EXAMPLE OF A USER-DEFINED FUNCTION]
:::

The quickest way to make sure others have access to the functions contained in packages is to include a `library()` call in your reprex, so they know to load the package too.

[CALLOUT--dev versions of packages]

::::::::::::::::::::::::::::::::::::::::::: callout
Sometimes it can be hard to figure out where a function comes from. Especially if a function comes from a package you use frequently, you might not remember where it comes from!

You can search for a function in the help docs with `??fun` (where "fun" is the name of the function). To explicitly declare which package a function comes from, you can use a double colon `::`--for example, `dplyr::select()`. Declaring the function with a double colon also allows you to use that function even if the package is not loaded, as long as it's installed.
:::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::: challenge
**Exercise:** For each of the following code snippets, identify all the packages used.

- Example (including an ambiguous function: `dplyr::select()` is a good one because it masks `plyr::select()`)
- Example where you have to look up which package a function comes from
- Example with a user-defined function that doesn't exist in any package
::::::::::::::::::::::::::::::::::::::::::: 

Now that we have a list of the packages that the helper will need to load in order to run our example, we can add those as `library()` calls to the top of our script.
XXX Stylistic question--when to use callouts vs. think-pair-share exercises vs. just talking?

But what if our helper doesn't have all of these packages installed? Won't the code not be reproducible?

Typically, we don't include `install.packages()` in our code for each of the packages that we include in the `library()` calls, because `install.packages()` is a one-time piece of code that doesn't need to be repeated every time the script is run. We assume that our helper will see `library(specialpackage)` and know that they need to go install "specialpackage" on their own.

Technically, this makes that part of the code not reproducible! But it's also much more "polite". Our helper might have their own way of managing package versions, and forcing them to install a package when they run our code risks messing up our workflow. It is a common convention to stick with `library()` and let them figure it out from there.
XXX this feels over-explained... pare it down!

::::::::::::::::::::::::::::::::::::::::::: callout
**Using require() to install packages conditionally**
There is an alternative approach to installing packages [insert content/example of the if(require()) thing--but note that explaining this properly requires explaining why require() is different from library(), why it returns a logical, etc. and is kind of a rabbit hole that I don't want to go down here.]
::::::::::::::::::::::::::::::::::::::::::: 

**Step 3: Dependencies (datasets and variables)**

We isolated the problem in our problem area, and we loaded all the necessary packages, so we're done, right? 

Not so fast.

The piece of code that we copied over came from line [LINE NUMBER] of our analysis script. We had done a lot of analyses before then, including modifying datasets and assigning intermediate objects/variables.

Our code snippet *depends* on all those previous steps, so when we isolate it in a new script, it might not be able to run anymore. More importantly, when a helper doesn't have access to the rest of our script, the code might not run for them either.

To fix this, we need to provide some additional context around our reprex so that it runs. 

::::::::::::::::::::::::::::::::::::::::::: challenge
**Exercise:** For each of the following code snippets, identify all the variables used

- [Straightforward example]
- [Example where they use a built-in dataset but it contains a column that that dataset doesn't actually contain.]
::::::::::::::::::::::::::::::::::::::::::: 

::::::::::::::::::::::::::::::::::::::::::: callout
Remember, you can rename variables in R, so a variable with the same name doesn't necessarily contain the same exact object!
::::::::::::::::::::::::::::::::::::::::::: 

Now that we've identified the variables and datasets used, what do *they* depend on? Where did they come from?

::::::::::::::::::::::::::::::::::::::::::: exercise
Map out the origins of the variables and datasets involved in your reprex. Starting with the list of variables you came up with in the previous exercise, draw arrows backwards to show what variables each one of those depends on, and so on, and so on, backwards.

It might help you to ask the question "Where did this come from?" for each variable.

What do you notice?

How can you make sure the helpers can access these objects too?
::::::::::::::::::::::::::::::::::::::::::: 

::::::::::::::::::::::::::::::::::::::::::: callout
Every object should be able to map back to either a file, a built-in dataset in R, or another intermediate step. If you found any variables where you weren't able to answer the "Where did this come from?" question, then that's a problem! Did you build a script that mistakenly relied on an object that was in your environment but was never properly defined?

Mapping exercises like this can be a great way to check whether your code is reproducible.

See the {targets} package for more.
::::::::::::::::::::::::::::::::::::::::::: 

Wow, this is getting long! 

We could use this map to guide us, finding the previous parts of the code that our reproducible snippet depends on and pasting them into the "reprex-script.R" file.

But we might find that there are so many dependencies that pretty soon, we've just re-created the original script! And then it won't be very minimal anymore.

As with other types of writing, creating a good minimal reprex takes hard work and time!

```
"I would have written a shorter letter, but I did not have the time."
- Blaise Pascal, *Lettres Provinciales*, 1657
```

We can make our lives easier if we realize that helpers don't always need the exact same variables and datasets, just reasonably good stand-ins. In the last episode, we learned how to make minimal reproducible datasets.

::::::::::::::::::::::::::::::::::::::::::: exercise
Brainstorm some places in your reprex where you could use minimal reproducible data to make your problem area code snippet reproducible.

Which of the techniques from the [data episode](LINK TO DATA EPISODE) will you choose in each case, and why?
::::::::::::::::::::::::::::::::::::::::::: 

(XXX note from KG to XOR and PL: While writing this, I started to wonder whether it would make more sense to switch the order of this episode and episode 4, introducing minimal datasets at this point when it becomes clear that we need them.
But I took some time to think, and I actually like it better this way. This way, we've given them the skillset of how to make a minimal dataset, and now they get to apply it (and understand better why to apply it) in this episode. So they get to build on a skill they already have. Vs. if we started with this repro code example, which is kind of high-level conceptual, and then said "oh and by the way you need this other skill, which we will now learn", I have a hunch it'll be harder for them to internalize the overarching workflow.
If you disagree, we can discuss, but right now I'm feeling pretty strongly that we should at least test run it in this order and see if learners agree that it works.)


**Takeaway: Using a minimal dataset simplifies not just the data but also the code, because it lets you avoid including data wrangling steps in your reprex!**

**Step 4: Simplify**

We're almost done! Now we code that runs because it includes the necessary `library()` calls and makes use of minimal datasets that still showcase the problem. Our script is almost ready to send to our helpers.

But maybe there are a few places we can trim this down even more. 

Reading someone else's code can be slow! We want to make it very, very easy for our helper to see which part of the code is important to focus on. Let's eliminate distractions.

There might be some more bells and whistles we can cut
XXX WHEN WRITING THE INITIAL CODE, NEED TO MAKE SURE IT INCLUDES THESE SO WE CAN REMOVE THEM HERE!
- exploratory steps that don't directly relate the problem, such as calls to `head()`, `View()`, `str()`, or similar (exception: if you're directly using these to showcase things like dimension changes that help illustrate the problem)
- extra bells and whistles on plots
- WHAT ELSE

The general procedure to take is: remove something, run the code, see whether it changes our ability to reproduce the problem. If it doesn't, we're safe to remove that thing!

::::::::::::::::::::::::::::::::::::::::::: exercise
Ex: removing various things, observing what happens, identifying whether or not we care about those things. (Need to include at least one that's tricky, like maybe it does change the actual values but it doesn't change their relationship to each other)
::::::::::::::::::::::::::::::::::::::::::: 

To review, here's our **road map**:
::::::::::::::::::::::::::::::::::::::::::: callout
**Road map for everything**
() Figure out whether your problem is caused by an error/warning that can be fixed by examining the help files and other quick debugging tactics (what peter covers in his ep)--what type of error
() Determine that you need a reproducible example:
If so, move on to the sub-roadmap for breaking your code down into simpler pieces
**Road map for simplifying code**
  0. Make a new script
  1. Identify the problem area (what is breaking?)
    - add it to the script
  2. Dependencies: functions and packages
    - identify all necessary packages and add them as library() calls
    - define any other functions
  3. Dependencies: variables and datasets
    - identify/map variables and datasets used
    - replace with minimal datasets (sub-step here: go make a minimal dataset!!! which we taught you how to do previously)
  4. Simplify the example even more
    - remove anything extra/distracting that can be removed
() Post your reprex or send it to someone to get help; understand the landscape of resources for doing that
::::::::::::::::::::::::::::::::::::::::::: 

Ex: reflection. That was a lot! Let's take a moment to think.
- What's one thing you learned in this episode, an insight, etc?
- What's one thing you're still confused about?

Ex: 
Putting it all together: Given a broken script, can you reduce it down to its smallest parts and make a minimal reprex?
